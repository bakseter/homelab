kube-prometheus-stack:
  prometheus:
    prometheusSpec:
      scrapeInterval: 30s

      retentionSize: 20GB # https://prometheus.io/docs/prometheus/latest/storage/#right-sizing-retention-size

      serviceMonitorNamespaceSelector:
        matchExpressions:
          - key: kubernetes.io/metadata.name
            operator: In
            values:
              - monitoring
              - mandagsmiddag

      storageSpec:
        volumeClaimTemplate:
          spec:
            accessModes: ['ReadWriteOnce']
            resources:
              requests:
                storage: 25Gi

      metricRelabelings:
        - sourceLabels: [__name__]
          regex: '.*_bucket'
          action: drop

        - sourceLabels: [__name__]
          regex: 'container_.*'
          action: drop

  grafana:
    enabled: false
    forceDeployDashboards: true

  kubeEtcd:
    enabled: false

  kubeControllerManager:
    enabled: false

  kubeScheduler:
    enabled: false

  kubeProxy:
    enabled: false

loki:
  loki:
    auth_enabled: false

    storage:
      type: s3
      bucketNames:
        chunks: loki-chunks
        ruler: loki-ruler
      s3:
        endpoint: minio.minio.svc.cluster.local:9000
        access_key_id: minio
        secret_access_key: minio123
        insecure: true

    commonConfig:
      replication_factor: 1

    podSecurityContext:
      seccompProfile:
        type: RuntimeDefault

    schemaConfig:
      configs:
        - from: 2024-04-01
          store: tsdb
          object_store: s3
          schema: v13
          index:
            prefix: loki_index_
            period: 24h

    ingester:
      chunk_encoding: snappy

    limits_config:
      allow_structured_metadata: true
      volume_enabled: true
      retention_period: 48h

    ruler:
      enable_api: true

    querier:
      max_concurrent: 4

    pattern_ingester:
      enabled: true

  minio:
    enabled: true

    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL

    securityContext:
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault

  lokiCanary:
    enabled: true
    push: false

  resultsCache:
    enabled: false

  deploymentMode: Distributed

  ingester:
    replicas: 1
    zoneAwareReplication:
      enabled: false

  queryFrontend:
    replicas: 1

  queryScheduler:
    replicas: 1

  distributor:
    replicas: 1
    maxUnavailable: 1

  compactor:
    replicas: 1
    working_directory: /data/retention
    compaction_interval: 10m
    retention_enabled: true
    retention_delete_delay: 2h
    retention_delete_worker_count: 5

  indexGateway:
    replicas: 1
    maxUnavailable: 1

  chunksCache:
    enabled: false
    # default is 500MB, with limited memory keep this smaller
    writebackSizeLimit: 100MB

  gateway:
    enabled: true

  bloomPlanner:
    replicas: 0
  bloomBuilder:
    replicas: 0
  bloomGateway:
    replicas: 0
  backend:
    replicas: 0
  read:
    replicas: 0
  write:
    replicas: 0
  singleBinary:
    replicas: 0

alloy:
  global:
    podSecurityContext:
      seccompProfile:
        type: RuntimeDefault

  alloy:
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL

    configMap:
      content: |
        loki.write "default" {
          endpoint {
            url = "http://monitoring-loki.monitoring.svc.cluster.local:3100/loki/api/v1/push"
          }
        }

        local.file_match "node_logs" {
          path_targets = [{
              __path__  = "/var/log/syslog",
              job       = "node/syslog",
              node_name = sys.env("HOSTNAME"),
              cluster   = "homelab",
          }]
        }

        loki.source.file "node_logs" {
          targets    = local.file_match.node_logs.targets
          forward_to = [loki.write.default.receiver]
        }

        discovery.kubernetes "pod" {
          role = "pod"

          namespaces {
            names = ["bakseter-net", "cloudflared", "immich", "jellyfin", "longhorn-system", "mandagsmiddag", "tailscale", "traefik"]
          }
        }

        discovery.relabel "pod_logs" {
          targets = discovery.kubernetes.pod.targets

          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            action = "replace"
            target_label = "pod"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            action = "replace"
            target_label = "container"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            action = "replace"
            target_label = "app"
          }

          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            action = "replace"
            target_label = "job"
            separator = "/"
            replacement = "$1"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
            action = "replace"
            target_label = "__path__"
            separator = "/"
            replacement = "/var/log/pods/*$1/*.log"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            action = "replace"
            target_label = "container_runtime"
            regex = "^(\\S+):\\/\\/.+$"
            replacement = "$1"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets    = discovery.relabel.pod_logs.output
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.static_labels {
              values = {
                cluster = "homelab",
              }
          }

          forward_to = [loki.write.default.receiver]
        }

        loki.source.kubernetes_events "cluster_events" {
          job_name   = "integrations/kubernetes/eventhandler"
          log_format = "logfmt"
          forward_to = [
            loki.process.cluster_events.receiver,
          ]
        }

        loki.process "cluster_events" {
          forward_to = [loki.write.default.receiver]

          stage.static_labels {
            values = {
              cluster = "homelab",
            }
          }

          stage.labels {
            values = {
              kubernetes_cluster_events = "job",
            }
          }
        }

  configReloader:
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 65535
      runAsGroup: 65535

grafana-operator:
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
